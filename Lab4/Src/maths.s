// Math routines for classic functions
.syntax unified
.cpu cortex-m33
.thumb
.section .text
// uint32_t Increment(uint32_t num);
.global Increment
.type Increment, %function
Increment:
    add r0, r0, #1
    bx lr
// uint32_t Decrement(uint32_t num);
.global Decrement
.type Decrement, %function
Decrement:
    sub r0, r0, #1
    bx lr
// uint32_t CalcOp(uint32_t sel, uint32_t a, uint32_t b);
// sel: 0=add,1=sub,2=mul,3=div
.global CalcFunc
.type CalcFunc, %function
CalcFunc:
    cmp r0, #0
    beq calc_add
    cmp r0, #1
    beq calc_sub
    cmp r0, #2
    beq calc_mul
    cmp r0, #3
    beq calc_div
    mov r0, #0
    bx lr

calc_add:
    add r0, r1, r2
    bx lr

calc_sub:
    sub r0, r1, r2
    bx lr

calc_mul:
    mul r0, r1, r2
    bx lr

calc_div:
    udiv r0, r1, r2
    bx lr



/* Assembly function for the greatest common divisor subroutine. `
The assembly is based on Euclid’s algorithm to find the GCD of two numbers. */

/* C Code equivalen of Euclide algorithm:
 	  while (b != 0) {
    	    Entry_t remainder = a % b;
    	    a = b;
    	    b = remainder;
    	  }
    	  result = a;
*/

.global CalcGCD
.type CalcGCD, %function
CalcGCD:

/*
uint32_t CalcGCD (uint32_t a, uint32_t b);
Registers:
r0 = a  r1 = b
*/

loop_while:
   cmp r1, #0
   beq gcd_result //  jump to result if b ==0

 /* Modulo expressed as arithmetic operations
 remainder = a%b = a- (b X [a/b]) */

   udiv r2, r0, r1 //  r2 = [a/b]
   mul r3, r2, r1  // r3 = b X [a/b]
   sub r4, r0, r3  // r4 = a- (b X [a/b])

   mov r0, r1 // a = b;
   mov r1, r4 // b = remainder;
b loop_while  //  repeat the while loop


gcd_result:
  bx lr //  return r0



// Assembly function for the factorial subroutine.
/*Based on this iteratif function:

result = 1;

if ((Entry_t) a == 0) {
    result = 1;
} else {
    for (Entry_t i = 1; i <= (Entry_t)a; i++) {
        result *= i;
    }
}
 */

.global CalcFactorial
.type CalcFactorial, %function

/*
uint32_t CalcFactorial (uint32_t a);
Registers:
r0 = a  r1 = i  r2 = result
*/

CalcFactorial:
   mov r1, #1  // Entry_t i = 1;
   mov r2, #1  // result = 1;

   cmp r0, #0 // if a == 0
   beq factorial_result  //  jump to result;

   loop_for_fact:
   cmp r1, r0
   bgt factorial_result  // jump to result if i > a

   mul r2, r2, r1  // result = result * i
   add r1, r1, #1  // i++
   b loop_for_fact // repeat the for loop

   factorial_result:
   mov r0, r2   // r0 = result
   bx lr       // return r0


//Fibonacci recursive assembly function generated by ChatGPT

.global fib
.type fib, %function

fib:
    push {r4, r5, lr}          @ Save registers (function is recursive)

    cmp r0, #0                 @ if n == 0 → return 0
    beq fib_base0
    cmp r0, #1                 @ if n == 1 → return 1
    beq fib_base1

    mov r4, r0                 @ Store n in r4 (because r0 will be overwritten)

    sub r0, r4, #1             @ Compute fib(n-1)
    bl fib
    mov r5, r0                 @ r5 = fib(n-1)

    sub r0, r4, #2             @ Compute fib(n-2)
    bl fib
    mov r1, r0                 @ r1 = fib(n-2)

    mov r0, #0                 @ Operation code: 0 = addition (CalcFunc)
    mov r2, r1                 @ r2 = fib(n-2)
    mov r1, r5                 @ r1 = fib(n-1)
    bl CalcFunc                @ r0 = fib(n-1) + fib(n-2)

    b fib_end

fib_base0:
    mov r0, #0                 @ return 0
    b fib_end

fib_base1:
    mov r0, #1                 @ return 1
    b fib_end

fib_end:
    pop {r4, r5, lr}           @ Restore registers
    bx lr                      @ Return




// Sort assembly function based on the bubble sort algorithm.

/* Bubble sort C function:
void CalcSort(uint32_t *a, uint32_t size)
{
    uint32_t i, j, temp;

    if (size < 2)
        return;

    for (i = 0; i < size - 1; i++)
    {
        for (j = 0; j < size - 1 - i; j++)
        {
            if (a[j] > a[j + 1])
            {
                // swap a[j] and a[j+1]
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}
*/

.global CalcSort
.type CalcSort, %function
CalcSort:
/* void CalcSort(uint32_t *a, uint32_t size)
Registers:
r0 = a* (array of numbers)  r1 = array size

*/

 push {r4-r10, lr}   //save the registers r4-r10 and their return address
 mov r2, #0  // r2 = i, i =0
 sub r5, r1, #1 // r5 = size -1

loop_for_sort: // outer loop for
  cmp r2, r5
  bge sort_result // jump to result if i => size - 1

  mov r3, #0 // r3 = j, j = 0

 inner_loop: // inner loop for
  sub r6, r5, r2 // r6 = (size -1) - i

  cmp r3, r6
  bge loop_result  // jump to result if j => (size - 1) - i
  add r8, r3, #1  // j = j +1
  ldr r9, [r0, r3, LSL #2]; // load a[j] in r9
  ldr r10, [r0, r8, LSL #2]; // load a[j + 1] in r10
  cmp r9, r10
  ble no_change // jump to no_change if a[j] > a[j + 1]
  str r10, [r0, r3, LSL #2];
  str r9, [r0, r8, LSL #2]; // swap a[j] and a[j+1] if a[j] <= a[j + 1]


  no_change: // (the order of the 2 consecutive elements stays intact)
  add r3, r3, #1 // j = j + 1
  b inner_loop // repeat the inner loop for

  loop_result:
  add r2, r2, #1 // i =i +1
  b loop_for_sort // repeat the outer loop for


sort_result:
 pop {r4-r10, pc} //restores the registers r4-r10 and return






/* Average assembly function.
C code faitful version:
/
uint32_t CalcAverage(uint32_t *a, uint32_t size)
{
    uint32_t i = 0;
    uint32_t result = 0;

    while (i < size) {
        result += a[i];
        i++;
    }

    result = (result * 10) / size;

    return result;
}
*/

.global CalcAverage
.type CalcAverage, %function
CalcAverage:

/*Registers:
/a* (array of numbers)    r1: size */

 push {r4, lr} //save r4 and its return address
mov r2, #0 // i =0
mov r3, #0  //result =0 (result of summation)


loop_for_avg:
   cmp r2, r1
   bge average_result // jump to result if i => size
   ldr r4, [r0, r2, LSL #2]; //load a[i] in r4
   add r3, r3, r4 //result = result + a[i]
   add r2, r2, #1 //i = i+1
   b loop_for_avg // repeat loop for

average_result:
mov r5, #10 //r5 =10
mul r3,r3,r5
 udiv r0, r3, r1 // result = (result *10) / size
 /*Note: to display the first decimal, we multiply the result by 10
  and then use % 10 in C*. The digits before the decimal point are
  obtained by multiplying result by 10 in C*/
pop {r4, pc} // restores r4-r10 and return









